\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.

%% IEEE CNS addition:
\makeatletter
\def\ps@headings{%
\def\@oddhead{\mbox{}\scriptsize\rightmark \hfil \thepage}%
\def\@evenhead{\scriptsize\thepage \hfil \leftmark\mbox{}}%
\def\@oddfoot{}%
\def\@evenfoot{}}
\makeatother
\pagestyle{empty}
\usepackage{booktabs} % For formal tables
\usepackage{amssymb}
%\usepackage{times,amsmath,epsfig}
\usepackage{graphicx}
\usepackage{url}
%\usepackage{mathptmx}
\usepackage{float}
\usepackage{pgfplots}
\usepackage{subfiles}
\usepackage{amsmath}
\usepackage{booktabs}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{tabularx}
%\usepackage{pgfplots}
%\usepackage{url}
\usepackage{multirow}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\begin{document}

\title{Securing IoT Firmware Dispatch System with Blockchain
%{\footnotesize \textsuperscript{*}Note: Sub-titles are not captured in Xplore and should not be used}
%\thanks{Identify applicable funding agency here. If none, delete this.}
}

\author{\IEEEauthorblockN{
Vince Bir\'{o},  Wei-Yang Chiu, and Weizhi Meng %and
%Eldon Tyrell\IEEEauthorrefmark{4}
}
%\IEEEauthorblockA{\IEEEauthorrefmark{1}Department of Computer Science, City University of Hong Kong, Hong Kong SAR}
\IEEEauthorblockA{SPTAGE Lab, Department of Applied Mathematics and Computer Science, \\Technical University of Denmark, Denmark}
%\IEEEauthorblockA{\IEEEauthorrefmark{4}Faculty of Computer Science, University of New Brunswick, Canada \\
%Email: \{weme@dtu.dk\}}
%\IEEEauthorblockA{\IEEEauthorrefmark{4}Tyrell Inc., 123 Replicant Street, Los Angeles, California 90210--4321}
}

\maketitle

\begin{abstract}
Internet-of-Things (IoT) devices have become a prevalent part of everyday life, making the need for IoT firmware security greater than ever. Firmware dispatch systems play a crucial role in maintaining the secure operations of IoT devices, where a compromise on the integrity of dispatches may simply ruin an IoT device. Hence it is essential to have robust solutions to safeguard such systems. With the advent of blockchain and Web3 technologies, there are new options of tackling security-related challenges. Blockchain provides a tamper-proof, secure, and fully distributed protocol, making it an excellent choice for a firmware dispatch system. In this work, we explore the existing blockchain-based solutions for distributing IoT firmware updates, and then propose a secure firmware dispatch system for IoT devices using Ethereum. Our system employs Web3.Storage, with the InterPlanetary File System and a peer-to-peer hypermedia protocol. In the evaluation, we demonstrate that our designed architecture is fast, reliable, and scalable by offering a firmware integrity validation. It can benefit a wide range of manufacturers who intend to increase the security of their IoT devices.

%This thesis explores the existing blockchain-based solutions for distributing IoT firmware updates. Furthermore, it proposes a secure firmware dispatch system for IoT devices using Ethereum. The system employs Web3.Storage, a hosted implementation of the InterPlanetary File System, a peer-to-peer hypermedia protocol. The proposed architecture is a fast, reliable, and scalable system offering a firmware integrity validation protocol. It can benefit a wide range of manufacturers who intend to increase the security of their IoT devices.
\end{abstract}

\begin{IEEEkeywords}
Blockchain, Dispatch system, Internet of Things, IPFS, Hypermedia protocol, Ethereum
\end{IEEEkeywords}

%\verb|{eqnarray}|

\section{Introduction}
Internet-of-Things (IoT) devices can offer many benefits (e.g., convenience) while also suffering various security challenges. In 2019, the Taiwan-based tech giant ASUS was believed to have had its update server compromised by hackers. Researchers estimated half a million devices affected during the incident. To worsen the situation, the incident remained undiscovered for over a month. The infected devices may receive malicious firmware, which allows the cyber-adversaries to install a backdoor~\cite{Zetter}. The same incident happened to Gigaset in 2021--a German smartphone manufacturer. The attackers were able to install arbitrary software on the devices~\cite{THN}. These incidents highlight the importance of firmware security and verifiability when it comes to IoT devices.

In recent years, IoT devices have become an essential part of everyday life. While being connected to the Internet provides many opportunities for users, it also comes with a greater need for security protection. According to a survey from 2021 made by the Open Web Application Security Project (OWASP), firmware integrity failures are one of the top ten vulnerabilities in applications~\cite{OWASP1}. In 2018, OWASP concluded that insecure update mechanisms are one of the most common issues with IoT devices~\cite{OWASP2}.

\begin{table*}[t]
\centering
\caption{Comparison of existing solutions}
\label{tab:LiteratureComparison}
\begin{tabular}{@{}lSSSm{4cm}@{}}
&{\textbf{Blockchain}}&{\textbf{Storage}}&{\textbf{Deployment}}&{\textbf{Notable Feature}} \\ \toprule
{\textbf{Bettayeb \emph{et al.}~\cite{Bettayeb2021}}}&{Hyperledger}&{Centralized}&{Permissioned}&{Client app} \\ \midrule
{\textbf{Sey \emph{et al.}~\cite{Sey2021}}}&{Not specified}&{IPFS}&{Permissioned}&{Key generation service} \\ \midrule
{\textbf{Yohan and Lo~\cite{Yohan2020}}}&{Ethereum}&{Centralized}&{Public}&{Performance analysis} \\ \midrule
{\textbf{Projjal \cite{Projjal2020}}}&{Ethereum}&{IPFS}&{Not specified}&{MultiSig wallets} \\ \midrule
{\textbf{Tsaur \emph{et al.}~\cite{Tsaur2020}}}&{Ethereum}&{Swarm}&{Private}&{Antivirus check} \\ \midrule
{\textbf{Krejci \emph{et al.}~\cite{Krejci2020} }}&{Ethereum}&{IPFS}&{Not specified}&{Combines IoT integrity and real-time channels} \\ \bottomrule
\end{tabular}
\vspace{-3mm}
\end{table*}

Keeping the firmware of IoT devices up-to-date is vital to ensure device security, although the ASUS and the Gigaset cases indicated that it can also be a vulnerability. Therefore, it is essential to find ways for reliable and secure IoT software updates. To achieve this, the verifiability and immutability of dispatches are crucial. This is where blockchain--an emerging distributed network technology can help, aiming to reach these requirements in an effective and secure way~\cite{Chiu2023_tii,LiWW2023_iotj}.

Blockchain technology is becoming increasingly popular, and its use cases are far beyond its original application in cryptocurrencies~\cite{b1,Shi2023}. The technology has seen widespread adoption, with the most popular applications being financial services, supply-chain management, intellectual property, governmental and healthcare services. According to CoinMarketCap~\cite{CoinMarketCap}, the existing crypto market capitalization could reach over 1 trillion USD. Blockchain offers several benefits, including security, transparency, immutability, and decentralization, all backed by solid cryptographic fundamentals. On the other hand, the technology is still under development, posing challenges such as scalability, operational cost, complexity in development, and the evolving regulatory landscape~\cite{Meng2018_ieee}.


\textbf{Motivation and contributions.} IoT firmware dispatch systems are designed to distribute and manage firmware updates. They are essential in maintaining the functionality and security of the ubiquitous IoT devices. Given the increasing number of firmware-related attacks, choosing a secure and reliable firmware dispatch system is crucial.

With the advent of decentralized applications (DApps)~\cite{Wu2021_spe}, firmware modification attacks in IoT devices can be addressed with the decentralized approach. The verifiability and the immutability of blockchain are auspicious ways of tackling these challenges. On the other hand, there are also challenges stemming from the fact that blockchain is a new and ever-changing field. This can be problematic when getting to the implementation stage, where the integration to other services might not be seamless just yet.

It is worth highlighting that DApps are applications built on top of a blockchain network, which offer all the benefits of blockchain while providing some services just like traditional applications~\cite{Chiu2022_provsec}. DApps are prone to censorship and are generally considered more secure and transparent than conventional applications~\cite{Brotsis2021}. However, as previously mentioned, the technology is still relatively new, and some non-trivial challenges might occur while implementing blockchain-based systems. To explore this point, our work has a special focus on implementing a practical, secure and verifiable blockchain-based firmware dispatch system, and providing an overview of the relevant technologies and their challenges.

In light of the recent developments within blockchain technology, some research focused on firmware updates. However, most of them did not cover implementation, nor did they provide an implementation-specific analysis but rather just a high-level assessment of the available solutions.
To fill this gap in the available research and to address these challenges, our work makes the following contributions:

\begin{itemize}
    \item We propose a secure firmware dispatch system for IoT devices using blockchain, which provides a protocol for verifying firmware integrity in a cryptographic way.
    \item We also introduce a highly practical approach by implementing our proposed system with a DApp and a client application. It also involves the assessment of the chosen technologies, as well as analyse of the implementation from a security and performance point of view.
\end{itemize}

%As we previously discussed that the maintenance records within the aviation industry require high integrity and traceability, we are encouraged to put Blockchain into the domain. In order to make the system more practical and closer to real world, we developed AirChain - a Blockchain-based aircraft maintenance record system, with the CLB, TLB and their partial procedure provided by China Airline, that is suitable for the real world.

\textbf{Organization.} Section~\ref{sec:2} describes the related work on the combination of blockchain and firmware update in IoT. Section~\ref{sec:3} details our proposed system including design requirements, system architecture, publication protocol, and data retrieval and verification protocol plus security considerations. Section~\ref{sec:4} presents our system implementation, client application design and system evaluation results. Section~\ref{sec:5} discusses our system performance and challenges in many aspects including security, privacy and performance. Finally, Section~\ref{sec:6} concludes our work.
	
\section{Related Work and Background}\label{sec:2}
In the literature, firmware update has received much attention due to its importance to IoT security.

Bettayeb \emph{et al.}~\cite{Bettayeb2021} proposed a HyperLedger-based architecture where the manufacturer stores the firmware update in a centralized manner. The network consists of vendor and gateway nodes. The vendor nodes are responsible for managing the firmware updates, and the gateways communicate with the IoT devices. Sey \emph{et al.}~\cite{Sey2021} demonstrated a solution where the nodes are in a permissioned blockchain consortium. It employs the IPFS for decentralized storage of the firmware updates. It proposes a key-generation service that manages keys with the possibility of revoking them. These keys are used to encrypt the updates sent by the server towards the IoT devices, which can then decrypt the update using their private key. While this work does not cover blockchain-specific details.

\begin{figure*}[t]
\centering
\includegraphics[width=.8\textwidth]{Assets/Image/Arch.png}
\caption{Proposed System Architecture}
\label{fig:Arch}
\vspace{-2mm}
\end{figure*}


Yohan and Lo~\cite{Yohan2020} also proposed a blockchain-based firmware update framework where the updates are stored in a centralized manner. It provides a way to support both push and pull update mechanisms. The solution utilizes the Ethereum Mainnet, and it supports multiple roles: device manufacturers and third-party firmware brokers. %The paper also gives a thorough performance and security analysis of the system.
Projjal \cite{Projjal2020} then outlined an Ethereum-based solution for firmware updating using IPFS, but this work does not clarify whether the proposed solution uses the Ethereum Mainnet or a private network. The solution utilizes IPFS via Infura, which provides an API and a dedicated gateway to access the IPFS network. Though it lacks specific details concerning the integration with Infura and IPFS. An additional layer of security is introduced through the utilization of MultiSig wallets. The authors described a local deployment using Ganache and Truffle for testing purposes.

Tsaur \emph{et al.}~\cite{Tsaur2020} proposed a blockchain-based multi-node firmware verification process. Before the update is saved, the system checks the update file with antivirus. The solution employs a distributed storage; however, it does not go into details. They used Ethereum Swarm as the distributed file storage and a private Ethereum network for testing. The solution only saves some information about the file on-chain and references the saved file from the decentralized storage. The IoT devices download the updates directly from the decentralized database.
Krejci \emph{et al.}~\cite{Krejci2020} presented an architecture for IoT devices, providing a firmware integrity channel and a real-time channel for processing the data collected from the devices. It utilizes Ethereum and Solidity for the smart contract. Their solution only stores a hash of the updates on-chain. The actual files are stored in a storage client, and the authors suggested using IPFS.

%\section{Comparison of existing solutions}

In summary, there have been several research studies utilizing blockchain and Ethereum. When it comes to file storage, there are examples of both centralized and decentralized solutions. In the latter, IPFS and Swarm technologies are used. The architecture of these systems usually includes a gateway to free the IoT devices from the burden of communication with the blockchain network. Table~\ref{tab:LiteratureComparison} provides a comparison among existing solutions regarding blockchain type, storage, deployment and feature.

In this work, we propose a scalable, performant, and secure architecture by using a hosted IPFS and a private Ethereum network. Our solution differs from the existing studies because it involves a unique approach to the file storage implementation. The solution offers decentralized storage with a fast HTTP IPFS gateway without the need of dedicated infrastructure, yet it can guarantee all the benefits of IPFS. 

Below are some background on the concepts used in this work.

\begin{itemize}
\item \texttt{IPFS.} One of the most popular decentralized file storage solutions is  InterPlanetary File System (IPFS), an open-source P2P network for content addressing. Similarly to Ethereum, it is a set of protocols that has many implementations. These protocols solve challenges like verifiability, centralization, and resilience.
    
\item \texttt{Content addressing.} On IPFS, data is addressed by its content rather than a location address in centralized solutions. This address is called \texttt{CID}, which contains a cryptographic hash of the addressed file and a codec that holds information about the interpretation of the data. The newest version is called \texttt{CID} v1, which contains the content hash, the encoding, the version, and the codec.

\item \texttt{Filecoin.} One of the solutions for making the use of IPFS easier is Filecoin, a blockchain protocol. The solution facilitates data storing and retrievals and financially incentivizes Filecoin nodes (storage providers) to keep data pinned to IPFS. When a user wants to store a file, a storage deal is created between the user and a storage provider. Once the file is stored, the client receives verifiable proof of this fact (called Proof of Replication), and the deal gets added to the Filecoin blockchain. 
\end{itemize}



\section{Our Proposed Approach} \label{sec:3}

In this section, we first analyze the requirements and then introduce the system model, by addressing all the requirements with a high-level architecture overview. We also provide some assumptions made when designing the system.

In addition, we define three major actors within the proposed  system, including \texttt{operators}, \texttt{vendors}, and \texttt{IoT devices} grouped into units. The operators are responsible for operating and maintaining the system. A vendor is an IoT device manufacturer. Vendors can publish firmware updates for the IoT devices. In this work, a unit means a group of IoT devices, which could be one physical location where the group forms a fleet of IoT devices.

\begin{figure*}[t]
\centering
\includegraphics[width=.65\textwidth]{Assets/Image/Publication.png}
\caption{Firmware update publication protocol}
\label{fig:Publication}
\vspace{-2mm}
\end{figure*}


\subsection{Design Requirements}

Here we introduce the system requirements to explain the motivation behind some of the design decisions made for the system model. Generally, the system generally has to meet the following three security conditions: confidentiality, integrity, and availability, in addition to scalability and performance.

\begin{itemize}
\item \texttt{Confidentiality.} This is about securing the data from unauthorized actors. When it comes to firmware updates, a vendor may want to protect their update from the public. However, in some cases, this is not important as long as the update's integrity is preserved. Since blockchain is a public ledger, everything is accessible to the public by default. Thus, it is crucial to address the question of confidentiality for the specific use cases. In this work, we aim to introduce a general-purpose firmware dispatch system; hence, it must provide a way to ensure the confidentiality of firmware updates.

\item \texttt{Integrity.} The most crucial aspect of any firmware dispatch system is the integrity of the updates distributed with it. It is vital to provide a way for integrity checks when a firmware is being distributed. To fulfill this requirement, there is a need for cryptographic proof that the file has not been tampered with and that the distributed update is identical to what was initially uploaded. Similarly, the IoT devices need a way to verify the integrity of the downloaded files.

\item \texttt{Availability.} While securing the confidentiality and integrity of the data is essential, it is of no use if the data is unavailable. Therefore, the proposed system model must be highly available. It must also be resilient against attacks targeting the system's availability, typically called DoS attacks, where intruders try to disrupt the service by overwhelming the network with traffic. %DoS attacks might be distributed if the attack is not performed from a single source but rather from a network of computers.

\item \texttt{Scalability.} There are some other requirements for a general case firmware dispatch system. One of these is the scalability of the system. To make a future-proof system, one needs to be able to scale up (or down) both the storage and the blockchain nodes of it. Further, it must provide a seamless experience regarding the speed of uploads and downloads. Some blockchain and storage solutions might take some time to finalize transactions and distribute the files. Therefore, it is essential to assess this property and to guarantee the speed and the viability of the proposed solution.

\item \texttt{Performance.} Another requirement stemming from the generality of the system is that the performance metrics of the IoT devices must be taken into consideration. One cannot assume that an IoT device can act as an active node in the network as it might not have the networking and computing capabilities to participate in it. This might be caused by a limitation in bandwidth, computing power, or some other characteristics of the device.


\end{itemize}


\subsection{System architecture}

In this work, we propose a secure firmware dispatch system using Ethereum and a distributed file storage solution, which provides a way for firmware integrity verification. Figure~\ref{fig:Arch} shows an overview of our proposed scheme.

The architecture consists of four main components: a network of nodes, a network of distributed file storage nodes, and for each unit, a gateway node and a fleet of IoT devices. The system utilizes an Ethereum-based private blockchain network where the operator maintains the network nodes.


\subsubsection{Network nodes}

The network nodes are full Ethereum nodes, and they are responsible for verifying and maintaining the blockchain. A smart contract (SC) is deployed to the network, which is responsible for keeping track of the firmware updates and the system usage. Regarding the number of nodes, more independent nodes can generally provide more security for the system; thus, it should always be adjusted to the requirements of a use case and the budget.

\subsubsection{File storage nodes}

We select \texttt{Web3.Storage} for storing the files, which employs Interplanetary File System (IPFS) under the hood and eliminates the need to self-maintain storage nodes. As a consequence, the nodes for file storage are managed by \texttt{Web3.Storage}, and the two systems can communicate over the public Internet via HTTPs.

\subsubsection{Gateway and IoT fleet}

Each unit involves a fleet of IoT devices, which must be controlled. These devices are not directly connected to the firmware dispatch system but through a gateway device. The gateway device acts as a dispatcher by downloading the updates and then forwarding them to the IoT devices. The gateway is also an Ethereum node as part of the private network since it retrieves information from the blockchain. For performance reasons and cost-effectiveness, these gateway devices are light Ethereum nodes, as they are only used for communicating with the smart contract. Since the gateway handles the aforementioned operations, the IoT devices are only required to accept the connection from the gateway and perform the update.

\subsubsection{Network deployment}

Our proposed model uses a private deployment model for the blockchain network. All participants connect to the same blockchain and use the same smart contract. If the use case requires storing additional information, e.g., the manufacturer of IoT devices or other information, then the smart contract would facilitate this feature. When a new participant joins the network, an administrator would register this information about the devices, and then they could start using the system.

%Using a private network was a design decision, and the benefits of it will be addressed in detail later in this paper.
It is important to note that the architecture is not restricted to a private blockchain. Everything could be used as is for a public deployment on the Ethereum Mainnet. For example, if an operator does not wish to maintain a network of nodes but instead prefers the Ethereum Mainnet, they can still use our proposed solution. %could utilize the solution proposed in this project.

\subsection{Publication Protocol}

Here we introduce the process of publishing a firmware update in our proposed system. Figure~\ref{fig:Publication} shows the workflow of our designed publication protocol. Note \texttt{CID} means Content Identifier, and if the \texttt{CID} is returned from the server will be denoted as \texttt{CID (server)}.



\begin{figure*}[t]
\centering
\includegraphics[width=.65\textwidth]{Assets/Image/POI.png}
\caption{Firmware integrity verification flow}
\label{fig:POI}
\vspace{-3mm}
\end{figure*}

Vendors can publish new firmware updates, where they can achieve this through a client application. The client communicates with the rest of the system. The client is also a node in the blockchain network, which is located at the vendor's site. When the vendor initiates the publication of a new update, the client packs the update into a ContentAddressed
Archive (\texttt{CAR}) and calculates the \texttt{CID}. Then, it uploads the file to \texttt{Web3.Storage} and verifies the \texttt{CID} from the server's response. If the two \texttt{CIDs} are identical, the file has not been tampered with, and the desired file is being distributed via IPFS. Once \texttt{Web3.Storage} finishes the upload, the client calls the smart contract to create a new update and sends the \texttt{CID} of the file with the metadata of the firmware update, which can complete the publishing process.

\subsection{Data Retrieval and Verification Protocol}

The retrieval process is always initiated by a client. It can reach it by querying the smart contract for available updates. Then, it can choose an update and construct the download URL from its \texttt{CID}. It downloads the update via the HTTP IPFS gateway w3link. Once the file is retrieved, the client needs a cryptographic proof of integrity of the update, that is why there is a need for an integrity verification protocol.

%The integrity of the files is based on \texttt{CID}, which were introduced in the previous chapter.
\texttt{CIDs} are created by hashing a representation of the file uploaded to the storage and by some additional information as a prefix. This process results in a unique \texttt{CID} for each file, which can be used later as proof of being tamper-free. Since IPFS and Web3.Storage use \texttt{CID} for addressing the files, the integrity is preserved by definition at the storage level. When the server transmits the file to the client, it can locally calculate the \texttt{CID} for the downloaded file and compare it with the received \texttt{CID} from the smart contract. Hence, the client has a cryptographic proof of integrity if the two \texttt{CIDs} are identical. The firmware integrity verification flow can be seen in Figure\ref{fig:POI}.



\subsection{Security Considerations and Discussion}

It was necessary to consider some issues during the design and the implementation of our proposed system. Certain aspects are out of the scope due to the complexity. Hence, our work considers the following context-specific simplifications and approximations.

\begin{itemize}
\item \texttt{Secure communications.} Each network participant is assumed to use secure communication channels via some forms of encryption, for example, HTTPs communication with TLS 1.3. The networks used in the architecture are also presumed to be as restrictive as possible, which means external communication is only allowed if needed.

\item \texttt{Secure runtime.} The proposed architecture and the implementation of the system are expected to be run as is without modification. Therefore, it is assumed that the hardware executing the code can guarantee secure runtime and is protected against physical and software-based attacks. One potential solution is to utilize a Trusted Platform Module (TPM)--a specialized chip. %Although the details about TPM and its implementation go beyond the scope of this research, in essence, it enables secure boot, hardware-level encryption, and system integrity checks.

\item \texttt{Gateway-specific implementation.} The architecture assumes that the gateway knows when to pull an update and can securely distribute it to the desired IoT device. It is also expected to handle network and other types of failures, for example, when an IoT device is unreachable.

\item \texttt{Access control.} Another assumption is access control regarding the client application, which the vendor manages. The distribution of access to specific roles is assumed to be done correctly by the operator and the vendor. Since each transaction made by the client is associated with a wallet address (an account) on Ethereum, the proper distribution of these accounts is also expected. As a consequence, it is assumed that no unauthorized actor can access the distributed Ethereum accounts of the network.
\end{itemize}

\section{Implementation and Evaluation} \label{sec:4}

\subsection{System Implementation}
In this part, we describe the development environment, the implementation of smart contract, and the client application (named Waffle).
The source code of the project is available at \url{https://github.com/codingbiro/waffle}. It contains the smart contract, the network scripts, the compilation scripts, the deployment scripts, and the client application.

%\subsubsection{Development environment}

%A well-chosen development environment is essential for productivity. To create the fundamentals of our system, I needed a development network, a \ac{sc}, and a convenient way to test and validate both.

\subsubsection{Hardhat setup and script}

For implementation, we set up a local Ethereum development network using Hardhat, and configured the network using Hardhat's configuration file (\texttt{hardhat.config.js}), where we set the Solidity version to 0.8.19. Then, we created a script in \texttt{package.json} to start the network with a node and saved the output in a file located at \texttt{scripts/target/network.init}. The \texttt{mkdir} command ensures that the directory exists.

Saving the output of the command can automatize the process later on. The output contains information like the network's address on \texttt{localhost} and the default accounts.

\subsubsection{Remix}
It is an IDE for Ethereum smart contract development, which can be used in a browser. Remix provides an editor based on the same fundamentals as Visual Studio Code. It supports linting, compiling, and deploying smart contract written in Solidity. It allows switching between Solidity versions conveniently, and then it can export the compiled file to IPFS, Swarm, or the host machine.


\subsubsection{Smart contract}

We developed an Ethereum smart contract (SC) using Solidity. It is responsible for keeping track of the available updates with some metadata attached to them. The final version of smart contract's source code can refer to the project link.

The system has three user groups: the owner, the updater, and the regular users. The owner is set in the smart contract's constructor based on whoever deploys the SC. The updaters are people with access to firmware update creation and editing. Regular users have access to the blockchain and can call the unrestricted public functions of the smart contract.

\begin{figure}[h]
\centering
\includegraphics[width=\columnwidth]{code1.png}
\caption{Code of \texttt{transferOwnership} function}
\label{fig:code1}
\vspace{-3mm}
\end{figure}

One standard management-related method is the transfer of ownership. The owner of the SC is a unique role since only the owner can add new updaters to the system. Hence, it is crucial to have access to this role. Firstly, we persist the owner and the array of users with updater-rights in the SC, which are both private. We then utilized \emph{function modifiers} to restrict access or to force some constraints before executing a function. In Solidity, modifiers are used to modify function behavior. To only allow a function to be called by the owner, we created an \texttt{ownerGuard} modifier. With the help of \texttt{ownerGuard}, we implemented the \texttt{transferOwnership} function (see Figure~\ref{fig:code1}). It takes the new owner's address as an input parameter. It removes the current owner from the updaters, then adds the new one as the owner and as an updater.

\subsubsection{Updates}

Here we describe how firmware updates are stored in the smart contract. The SC keeps the following information for each update: the hash of the firmware (the \texttt{CID}), an id (to have a shorter identifier), the name of the firmware, the version of the firmware, the preferred filename of the upload (used when downloading), the timestamp of the creation, the uploader of the firmware, and finally two boolean variables: one for enabling it, the other one is for marking it as a stable release. %The representation of an Update and the array of updates in Solidity can be seen in the following code extract.

Function modifiers can take arguments, allowing more complex logic within the modifier. When creating firmware updates, it is essential not to have version collision. Thus, we defined a version guard that checks for version uniqueness, as shown in Figure~\ref{fig:code2}. It also takes an additional id parameter to allow invoking this function when editing an update (and it would collide with itself).

\begin{figure}[h]
\centering
\includegraphics[width=\columnwidth]{code2.png}
\caption{Code of \texttt{uniqueVersionGuard} function}
\label{fig:code2}
\vspace{-3mm}
\end{figure}

\begin{table*}[t]
\centering
\caption{\acs{api} endpoints of the application}
\label{tab:API}
\begin{tabular}{@{}lSSm{6cm}@{}}
{\textbf{Path}}&{\textbf{Method}}&{\textbf{Input Type}}&{\textbf{Description}} \\ \toprule
{\texttt{/updates}}&{GET}&{-}&{Returns all firmware updates} \\ \midrule
{\texttt{/updates}}&{POST}&{\texttt{CreateUpdateInput}}&{Creates a new firmware update} \\ \midrule
{\texttt{/updates/[id]}}&{GET}&{-}&{Returns a firmware update and its download URL} \\ \midrule
{\texttt{/updates/[id]}}&{PUT}&{\texttt{EditUpdateInput}}&{Edits an update and returns the new object} \\ \midrule
{\texttt{/information}}&{GET}&{-}&{Returns all system information} \\ \bottomrule
\end{tabular}
\end{table*}

Having defined the structure of the updates, the updater guard, and the version guard, we designed a method for creating updates, called \texttt{createFirmwareUpdate}. It takes the following information about the new firmware update: the hash of it (the \texttt{CID}), the filename, the two boolean values, and the corresponding name and version. If the guards allow the function execution, it adds a new update to the array of updates. Updaters can edit information about the firmware updates in case there was a mistake at the time of creation. The function \texttt{editFirmwareUpdate} takes the identifier of the update and the updated values as input (see Figure~\ref{fig:code3}). The editable fields for each update are \texttt{name}, \texttt{version}, \texttt{filename}, \texttt{isEnabled}, and \texttt{isStable}. Finally, the function returns the edited update with its new values.

\begin{figure}[h]
\centering
\includegraphics[width=\columnwidth]{code3.png}
\caption{Code of \texttt{editFirmwareUpdate} function}
\label{fig:code3}
\vspace{-3mm}
\end{figure}

\begin{figure*}[t]
\centering
\includegraphics[width=.7\textwidth]{Assets/Image/Waffle.png}
\caption{Firmware updates listed in the client application}
\label{fig:Waffle}
\vspace{-3mm}
\end{figure*}

\subsubsection{Linting}

We utilized an Node Package Manager (NPM) package called \texttt{solhint} for linting our Solidity code. This package provides security and style guide validations. We configured \texttt{solhint} to extend their shareable configuration called \texttt{solhint:recommended}. This configuration provided our system with a solid base for writing coherent and secure smart contract. 


\subsection{Client Application}
To facilitate the operations, we used Svelte to implement the client application. Svelte can be used to not only build the frontend but also the backend of the application. The application aims to show the capabilities of the proposed system from a vendor's perspective. The main features of the client application are: creating an update, listing updates, viewing and editing an update's information, and retrieving an update file.

\subsubsection{Backend}

The backend endpoints are defined in a directory called \texttt{src/routes/api}. To create an API route in Svelte, we created a \texttt{+server.ts} file inside a folder. The folder's name determines the route for the endpoint, just like with frontend routes. In particular, we created three different REST API routes: one for updates (called Updates endpoint), one for a specific update (called Update endpoint), and one for getting the system information (like the wallet address and network address). The implemented routes and methods can be seen in Table~\ref{tab:API}.


The core functionality is implemented in the Updates and the Update endpoints. The Updates endpoint can return all updates (or an empty array). It also enables new firmware creation by accepting a \texttt{CreateUpdateInput} (defined in the smart contract) with \texttt{Method='POST'}, which creates a new firmware update if the input is valid. The Update endpoint resides at \texttt{/updates/[id]}, where \texttt{id} is a dynamic parameter. The dynamic parameter here refers to the id of a firmware update; for example, a firmware with \texttt{id=10} would be available at \texttt{GET /updates/10}. This route is also used to edit updates with the \texttt{PUT} request method, where the input is expected to be of type \texttt{EditUpdateInput} (also defined in the smart contract).

We employed two helper functions that enable us to use Web3 and Web3.Storage, named \texttt{web3Helper} and \texttt{web3storageHelper} respectively. The first one creates a Web3 HTTP instance \& a Contract instance, initializes the default account, and handles relevant errors. The second one creates a Web3.Storage instance. We can avoid code duplication and optimize memory usage with these helpers.

Here we describe the Updates endpoint in detail, as it contains the most essential parts of the backend. To retrieve all updates, it uses \texttt{web3Helper} to call the smart contract's \texttt{getFirmwareUpdates} method and returns them in a JSON response (or throws an error). When creating a new firmware update, the endpoint expects a POST request with an input in a \texttt{FormData} object. If the input is valid, it calls a function that handles the upload. The upload handler uses \texttt{web3storageHelper} to upload the file to Web3.Storage. Before uploading it, it builds the \texttt{CAR} locally and saves its \texttt{CID}. Once the upload is done, it compares the local \texttt{CID} with the one returned from Web3.Storage. If they are matched, it returns the \texttt{CID}; otherwise, it throws an error. Next, the update has to be saved to the blockchain. To achieve this, the input is prepared for it, and the gas cost of the operation is estimated utilizing \texttt{web3Helper}. Then, it calls the smart contract's \texttt{createFirmwareUpdate} method through \texttt{web3Helper}. Finally, it returns the \texttt{CID} unless there is an error. %The source code of the Updates API endpoint can be found in Appendix~\ref{chap:api}.


\subsubsection{Frontend}

The frontend of the application consists of three routes. Route \texttt{/} has a permanent server-side redirected to the second route \texttt{/dashboard}. The route \texttt{/information} displays the system information.

The dashboard page facilitates the CRUD operations for updates. It displays all updates in a table with all of their details, which can be seen in Figure~\ref{fig:Waffle}. Each row is clickable, which allows users to view the details of an update in a modal. Users can download and edit the firmware via the modal. The download feature uses \texttt{w3link} to retrieve the file. The modal for firmware editing can be seen in Figure~\ref{fig:Edit}. The dashboard incorporates the creation of a new update. Once all fields are filled out, and the user clicks save, it performs the firmware update process creation and refreshes the list of updates. %It is done through a similar modal to Figure~\ref{fig:Edit}, but it also lets the user input the file.



\begin{figure}[t]
\centering
\includegraphics[width=.45\textwidth]{Assets/Image/Edit.png}
\caption{Editing a Firmware update}
\label{fig:Edit}
\vspace{-3mm}
\end{figure}

\subsection{System Evaluation}

\subsubsection{Main idea} We validate the proposed system by first showing that there is no way one can change an update after publishing a firmware update. Then, we show that a client can always get a proof of integrity when retrieving an update.

As shown in Figure~\ref{fig:Publication}, when a user initiates the publication of a new firmware update, the client locally builds the CAR and saves the file's \texttt{CID}. Then, it uploads the \texttt{CAR} to \texttt{Web3.Storage} and retrieves its \texttt{CID}. At this point, the client application has two \texttt{CIDs}: one is calculated locally and one is received from the server. The client compares these two and only continues the execution if they are identical. Then, it finalizes the update by adding its details to the blockchain, providing an immutable record. The \texttt{CID} of a file is always based on its contents, and any change in the contents will result in a different \texttt{CID}. Hence, if someone tries to change the firmware later on, then the \texttt{CID} of the file will be changed on IPFS, and will not match with the value from the blockchain network.

Then, if a client wants to ensure the integrity of a retrieved firmware update, it can get a proof of it with some simple steps. First, it queries the blockchain for information about one update containing the \texttt{CID} and the file URL. Then, it retrieves the update through \texttt{Web3.Storage}. Finally, it calculates the \texttt{CID} of the retrieved file locally, and if it does not match what it received from the blockchain, it discards the file.

\subsubsection{Performance tests}\label{sec:test}

We performed two tests to explore the performance and benchmark the storage provider. In both tests, we benchmark the upload and distribution speed. The distribution speed means retrieving the uploaded file from a different device. So we focus on testing the download speed. We run these tests three times with differing file sizes: 2 MB, 11 MB, and 48 MB.

\begin{figure}[t]
\centering
\includegraphics[width=.5\textwidth]{Assets/Image/Test.png}
\caption{Output of performance tests}
\label{fig:Test}
\end{figure}

In particular, we utilized Playwright--a powerful testing tool that provides reliable end-to-end testing. We then wrote a Playwright test to cover the first case, where the test consists of creating a new firmware update through the user interface. Then, it tries to retrieve the uploaded firmware. The output of the first test can be seen in Figure~\ref{fig:Test}, and Table~\ref{tab:Test} describes the upload and download times for the files.% can be seen in the following table.

\begin{table}[t]
\centering
\caption{Tests for firmware uploads and downloads}
\label{tab:Test}
\begin{tabular}{@{}SSS@{}}
{\textbf{File size (MB)}}&{\textbf{Upload speed (ms)}}&{\textbf{Download speed (ms)}} \\ \toprule
{2}&{3378}&{693} \\ \midrule
{10.7}&{4226}&{827} \\ \midrule
{48}&{7028}&{1682} \\ \bottomrule
\end{tabular}
\end{table}

After the first test, we manually tested the distribution times with two separate devices connected to different networks. It is found that there is no difference regarding distribution times. The new files are practically instantly available through w3link regardless of where the request is coming from. As a consequence, the chosen approach to test the retrieval times on one machine is adequate.


We also performed additional tests on six firmware updates from the computer networking company Ubiquiti~\cite{Ubiquiti}. The file sizes ranged from 8 MB to 403 MB. We ran the same Playwright test with the six new firmware updates and repeated this twice. Hence we got results from three runs in total. Then, we calculated the average upload and download times for each case. Figure~\ref{fig:tikz} presents the average download and upload speeds for each file.

\begin{figure}[t]
\centering
\includegraphics[width=.45\textwidth]{downloadspeed.pdf}
\caption{Average upload and download speeds per file}
\label{fig:tikz}
\vspace{-2mm}
\end{figure}


Further, we compared the time differences in each case between the runs since the \texttt{CID} is the same on the second and the third attempts. To highlight the results, we measured the difference between runs in upload/download speeds. These changes are summarized in Figure~\ref{fig:sum}, which shows the change in percentages between the first and the second run and between the second and the third run. We highlighted the outstanding changes with red (more significant differences) and orange. We also show the file size for each case and the time consumption of first run.

\begin{figure}[t]
\centering
\includegraphics[width=.5\textwidth]{changesinspeed.pdf}
\caption{The changes regarding upload ($\Uparrow$) and download ($\Downarrow$) speeds between runs per file}
\label{fig:sum}
\vspace{-2mm}
\end{figure}

%The source code for the performance tests can be found in Appendix~\ref{chap:test}. The entire Playwright setup and files from the first test are available in the project's repository under the \texttt{tests} directory.

\section{Discussion} \label{sec:5}

In this section, we discuss the performance of our proposed system regarding security, privacy, and performance, in addition to the usage of gateway and file-storage.

\subsection{Security and privacy analysis}
We assess the system from a security and privacy point of view, with the following aspects: user authentication, upload encryption, integrity verification, blockchain deployment type, and network attacks.

\begin{itemize}
    \item \texttt{User authentication.} Keys are pre-distributed for clients, and access to the client is managed by the vendor. The security can be enhanced by utilizing MultiSig wallets and key revocation. MultiSig wallets can be used to enhance security by requiring more than one signature on each transaction. Consequently, attackers need to obtain all signer-keys to succeed, making the attack much more complex. Key revocation can be helpful when a key is compromised. The two solutions combined can fulfill the security requirements for high-risk applications.
    \item \texttt{Upload encryption.} Content is addressed with \texttt{CID} in the system; thus, one has to know the \texttt{CID} of a file to retrieve it. Retrieval becomes hard without knowing the \texttt{CID}. This level of obscurity is enough for many use cases. On the other hand, a company might want to further enhance the privacy of these files. Privacy enhancement can be done by encrypting the files before uploading them, which could be a simple step before creating the \texttt{CAR} on the server. For example, CryptoJS--a JavaScript library  could be used to encrypt and decrypt files with the AES standard and a pre-distributed secret without adding much overhead to the system. Encryption would increase the privacy aspect of the system, making unauthorized access to the file contents practically impossible.
        
    \item \texttt{Verifying a file.} A protocol for ensuring file integrity was validated previously in Section~\ref{sec:5}-B. The process provides a secure and straightforward approach to get cryptographic proof of data authenticity. Hence, system participants can have a reliable and performant way to verify files.
        
    \item \texttt{Blockchain deployment.} It is a security, privacy, and performance consideration whether the blockchain network is a private or public deployment. Private networks provide great scalability options, and they offer strong privacy. Whereas public networks are harder to scale, and it is harder to maintain privacy since they are accessible by anyone. However, they can provide more security as they are larger networks.
        
    \item \texttt{Network attacks.} The proposed system assumes the use of secure communication channels with strong encryption, such as TLS that ensures data integrity and confidentiality and protects against Man-in-the-Middle attacks like spoofing. However, in the case where a client suffers from DNS pollution when retrieving a file from IPFS, and as a result, it gets a modified file, the file integrity protocol would still be able to detect the modification. The hash value of the received file would not match with the one on-chain. Hence, the client would discard the file.
\end{itemize}

\subsection{Performance analysis}

The performance metrics of the system's upload and download speeds can be seen in Section~\ref{sec:5}-B. The upload speeds were between 3 and 27 seconds, while the file sizes ranged between 7 MB and 403 MB. After running numerous tests, the system proved to be reliable and fast for managing updates. The average download speeds ranged between 0.5 and 13 seconds for the same files. %Figure~\ref{fig:Test} shows a clear correlation between file size and the speed, which is unsurprising.

When testing file retrievals three times in a row, there was an increase in the speed of downloads after the second try. However, the third retrieval was similar to the second one. Table~\ref{tab:Test} summarizes the changes between retries.

The performance tests indicate that \texttt{Web3.Storage} offers a robust solution for file storage. The service is highly scalable, and it is constantly being improved. Among the exciting projects, the team behind \texttt{Web3.Storage} is currently working on a new API, called \texttt{w3up-client}\footnote{\url{https://github.com/web3-storage/w3up-client}}, which will offer better performance for uploads.

\subsection{Comparison to related solutions}

When comparing the performance of our proposed system to similar ones introduced in Section~\ref{sec:2}. Our proposed architecture utilizes a gateway device that forwards updates to the IoT devices. Using a gateway is considerably better compared to having IoT devices connect directly to the blockchain network since these devices may not fulfill the minimum requirements to use the network reliably. In addition, the gateway device may reduce bandwidth requirements in the IoT devices, perform pre-processing on the updates (e.g., decryption), and reduce latency.

Regarding the file-storage solution, \texttt{Web3.Storage} offers several advantages. It is a highly scalable, cloud-native implementation of IPFS with solid performance and reliability. When it comes to other hosted IPFS solutions, \texttt{Web3.Storage} stands out by involving an IPFS HTTP gateway that is at least 2-3 times faster than other gateways~\cite{3perf}. Further, with the help of Filecoin deals, \texttt{Web3.Storage} users can ensure that their files are being stored on IPFS by the desired number of replicates.


\section{Conclusion} \label{sec:6}
IoT devices have become prevalent in everyone's day-to-day life. Thus, there is an increased need for IoT security, in which firmware dispatch systems play a crucial role. This work aimed to look at blockchain-based firmware dispatch solutions to provide a more reliable and secure architecture for IoT updates.

In this work, we proposed and implemented a firmware dispatch system that consists of the following components: a smart contract, a network setup script, and a client application for vendors. The implementation enables its users to store and retrieve firmware updates in a decentralized manner, utilizing blockchain and IPFA. Our system allows fast and reliable firmware updates while keeping the operational tasks relatively easy. The simplicity and speed of the system did not compromise security and privacy, and the integrity of the files was guaranteed. Our designed client application showcased the system's capabilities in a practical way from a vendor's point of view. It enables interaction with the proposed system through a web interface, and it also acts as an assessment of the available technologies that enable Web3 applications in a browser.







%\section*{Acknowledgment}
%The sources and test codings are be available on request.
%This project is partially supported by H2020 DataVaults.


%\section*{References}
%\bibliographystyle{IEEEtran}
% argument is your BibTeX string definitions and bibliography database(s)
%\bibliography{sources.bib}


\begin{thebibliography}{100}

\bibitem{Zetter}
Hackers Hijacked ASUS Software Updates to Install Backdoors on Thousands of Computers, 2019. (accessed on 20 July 2023) \url{https://www.vice.com/en/article/pan9wn/hackers-hijacked-asus-}
\url{software-updates-to-install-backdoors-on-thousands-of-computers}

\bibitem{THN}
PreInstalled Malware Dropper Found On German Gigaset Android Phones, 2021. (accessed on 20 July 2023)
\url{https://thehackernews.com/2021/04/pre-installed-malware-dropper-found-on.html}


\bibitem{OWASP1}
OWASP. OWASP Top 10 2021. (accessed on 6 August 2023)
\url{https://owasp.org/Top10/A08_2021-Software_and_Data_Integrity_Failures/}

\bibitem{OWASP2}
OWASP. OWASP IoT Top 10 2018. (accessed on 6 August 2023)
\url{https://owasp.org/www-pdf-archive/OWASP-IoT-Top-10-2018-final.pdf}

\bibitem{CoinMarketCap}
CoinMarketCap. Global Cryptocurrency Market Charts, 2023. (accessed on 10 August 2023)
\url{https://coinmarketcap.com/charts}

\bibitem{Ubiquiti}
Ubiquiti. Software Downloads. 2023.  (accessed on 10 August 2023)
\url{https://www.ui.com/download/releases/firmware}

\bibitem{3perf}
w3link. Software Downloads. 2023. (accessed on 10 August 2023)
\url{https://web3.storage/products/w3link/}

\bibitem{Bettayeb2021}
M. Bettayeb, Q. Nasir, and M.A. Talib,
``Hyperledger-Based Secure Firmware Update Delivery for IoT Devices," \emph{Proc. ArabWIC}, pp. 10:1-10:5, 2021.

\bibitem{Brotsis2021}
S. Brotsis, K. Limniotis, G. Bendiab, N. Kolokotronis, and S. Shiaeles,
``On the suitability of blockchain platforms for IoT applications: Architectures, security, privacy, and performance," \emph{Comput. Networks} 191, 108005, 2021.

\bibitem{Sey2021}
C. Sey et al.,
``Firmblock: A Scalable Blockchain-Based Malware-Proof Firmware Update Architecture with Revocation for IoT Devices," \emph{Proc. 18th International Computer Conference on Wavelet Active Media Technology and Information Processing (ICCWAMTIP)}, pp. 1-7, 2021.

\bibitem{Chiu2022_provsec}
W.Y. Chiu, W. Meng, W. Li, and L. Fang, ``FolketID: A Decentralized Blockchain-based NemID Alternative against DDoS Attacks," \emph{Proc. ProvSec 2022}, pp. 210-227, 2022.

\bibitem{Chiu2023_tii}
W.Y. Chiu, W. Meng, and C. Ge, ``NoSneaky: A Blockchain-based Execution Integrity Protection Scheme in Industry 4.0," \emph{IEEE Transactions on Industrial Informatics}, vo. 19, no. 7, pp. 7957-7965, 2023.

\bibitem{Projjal2020}
P. Gupta,
``A decentralized approach towards secure firmware updates and testing over commercial IoT Devices," CoRR abs/2011.12052, pp. 1-6, 2020.

\bibitem{Krejci2020}
S. Krejci, M. Sigwart, and S. Schulte,
``Blockchain- and IPFS-Based Data Distribution for the Internet of Things," \emph{Proc. ESOCC}, pp. 177-191, 2020.

\bibitem{LiWW2023_iotj}
W.W. Li, W. Meng, K.H. Yeh, and S.C. Cha, ``Trusting Computing as a Service for Blockchain Applications," \emph{IEEE Internet of Things Journal}, vo. 10, no. 13, pp. 11326-11342, 2023.

\bibitem{Meng2018_ieee}
W. Meng, E.W. Tischhauser, Q. Wang, Y. Wang, and J. Han, ``When Intrusion Detection Meets Blockchain Technology: A Review," \emph{IEEE Access}, vol. 6, no. 1, pp. 10179-10188, 2018.

\bibitem{b1}
S. Nakamoto, ``Bitcoin, A Peer-to-Peer Electronic Cash System'', 2008.

\bibitem{Shi2023}
Z. Shi, C. de Laat, P. Grosso, and Z. Zhao,
``Integration of Blockchain and Auction Models: A Survey, Some Applications, and Challenges," \emph{IEEE Commun. Surv. Tutorials} vol. 25, no. 1, pp. 497-537, 2023.

\bibitem{Tsaur2020}
W.J. Tsaur, J.C. Chang, and C.L. Chen,
``A Highly Secure IoT Firmware Update Mechanism Using Blockchain," \emph{Sensors} vol. 22, no. 2, 530, 2020.

\bibitem{Wu2021_spe}
K. Wu, Y. Ma, G. Huang, and X. Liu,
``A first look at blockchain-based decentralized applications," \emph{Softw. Pract. Exp.} vol. 51, no. 10, pp. 2033-2050, 2021.

\bibitem{Yohan2020}
A. Yohan and N.W. Lo,
``FOTB: a secure blockchain-based firmware update framework for IoT environment," \emph{Int. J. Inf. Sec.} vol. 19, no. 3, pp. 257-278, 2020.




%\bibitem{Papadimitratos2008}
%P. Papadimitratos, G. Calandriello, J.-P. Hubaux, A. Lioy, Impact of Vehicular Communications Security on Transportation Safety. CoRR abs/0808.2666, 2008.



	
	%\bibitem{b56} ``Security Scanner for Ethereum Smart Contracts,'' ICE Center - ETH Zurich, Accessed on: July 3, 2020. [Online] Available: \\ \url{https://securify.chainsecurity.com/}
\end{thebibliography}
%\vspace{12pt}
%\color{red}
%IEEE conference templates contain guidance text for composing and formatting conference papers. Please ensure that all template text is removed from your conference paper prior to submission to the conference. Failure to remove the template text from your paper may result in your paper not being published.

\end{document}
